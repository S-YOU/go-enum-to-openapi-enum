package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io/ioutil"
	"log"
	"os"
	"path"
	"strings"
)

const (
	tplBefore = `# Yaml generated by enum-gen. DO NOT EDIT.
%s:
  type: string
  description: %s
  enum:
`
	tplEnum    = "    - %s\n"
	tplExample = "  example: %s\n"
)

var (
	inFolder  = flag.String("in", "src", "input folder")
	outFolder = flag.String("o", "dest", "output folder")
)

func main() {
	flag.Parse()

	files, err := ioutil.ReadDir(*inFolder)
	if err != nil {
		log.Fatal(err)
	}

	for _, fInfo := range files {
		if fInfo.IsDir() {
			continue
		}
		inPath := path.Join(*inFolder, fInfo.Name())
		outPath := path.Join(*outFolder, strings.Replace(fInfo.Name(), ".go", ".yaml", 1))
		if err := parseInto(inPath, outPath); err != nil {
			log.Fatal(err)
		}
	}
}

func parseInto(path string, outPath string) error {
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
	if err != nil {
		return err
	}

	lastComment := "No Description"
	var names []string
	var typeName, typeTypeName string
	ast.Inspect(f, func(n ast.Node) bool {
		switch spec := n.(type) {
		case *ast.Comment:
			if typeName == "" && len(spec.Text) > 2 {
				lastComment = strings.TrimSpace(spec.Text[2:])
			}
		case *ast.TypeSpec:
			if t, ok := spec.Type.(*ast.Ident); ok {
				typeName = spec.Name.Name
				typeTypeName = t.Name
				return false
			}
		case *ast.GenDecl:
			if len(spec.Specs) > 0 {
				for _, x := range spec.Specs {
					if v, ok := x.(*ast.ValueSpec); ok && len(v.Names) > 0 {
						names = append(names, v.Names[0].Name)
					}
				}
			}
		}
		return true
	})

	if typeName != "" && typeTypeName != "" && len(names) > 1 {
		buf := bytes.Buffer{}
		buf.WriteString(fmt.Sprintf(tplBefore, typeName, lastComment))
		var example string
		for i, x := range names {
			if strings.HasPrefix(x, typeName) {
				enumName := x[len(typeName):]
				if i != 0 || enumName != "Unknown" {
					buf.WriteString(fmt.Sprintf(tplEnum, enumName))
				}
				if i == 1 {
					example = fmt.Sprintf(tplExample, enumName)
				}
			}
		}
		buf.WriteString(example)

		outFile, err := os.OpenFile(outPath, os.O_CREATE|os.O_RDWR|os.O_TRUNC, 0644)
		if err != nil {
			log.Fatal(err)
		}
		defer outFile.Close()

		if _, err := outFile.Write(buf.Bytes()); err != nil {
			return err
		}
	}
	return nil
}

